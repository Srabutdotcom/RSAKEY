import{ASN1 as V}from"npm:@lapo/asn1js";import{Base64 as q}from"npm:@lapo/asn1js/base64.js";import{Defs as U}from"npm:@lapo/asn1js/defs.js";import o from"npm:big-integer";function h(r,t,e){if(arguments.length==0)return TypeError("Expected 1 parameter but nothing");if(arguments.length==1)return!0;if(arguments.length==2){if(!(t instanceof Array))return TypeError("Parameter 2 must be Array");if(t.length==0)return!0;if(t.some(n=>{let s=typeof n;return s=="function"?r instanceof n:s=="object"&&typeof r=="object"?n===null||r===null?r===n:L(r,n):typeof r===n})==!1)return TypeError("Unexpected type of value")}return arguments.length==3&&e&&e.includes(r)==!1?TypeError(`Value is out of range, valid value should be within ${e.join(", ")}`):!0}function L(r,t){let e=Object.entries(r),n=Object.entries(t);return n.length==0&&e.length==0?!0:n.every((s,i)=>{let[a,c]=s,[l,u]=e[i],f=[];return typeof c!="object"?f.push(typeof c):c instanceof Object?f.push(c):f.push(c.constructor),l===a&&h(u,f)==!0})}import*as B from"@stablelib/sha256";import*as x from"@stablelib/sha384";import*as j from"@stablelib/sha512";var v=class{validSHA=[256,384,512];sha=256;saltLength=32;hash={sha256:B,sha384:x,sha512:j};OS2IP=w;I2OSP=D;I2OSP_array=b;I2OSP_uint8=b;RSASP1=T;RSAVP1=I;constructor(t,e){if(M(t))return TypeError("Parameter 1 is mandatory in the form of PEM String");if(F(t)==!1)return TypeError("Parameter 1 is not in the form of PEM String");this.enc=q.unarmor(t),this.asn1=V.decode(this.enc);let{type:n,key:s}=N(this.asn1);if(n.name!=="RSAPrivateKey")return TypeError(`Expected RSAPrivateKey but got ${n.name}`);this.type=n,this.key=s,this.nUint8=this.component("n"),this.version=s.sub[0].content(),this.n=o(s.sub[1].content().split(/\n/)[1]),this.e=o(s.sub[2].content()),this.d=o(s.sub[3].content().split(/\n/)[1]),this.p=o(s.sub[4].content().split(/\n/)[1]),this.q=o(s.sub[5].content().split(/\n/)[1]),this.dP=o(s.sub[6].content().split(/\n/)[1]),this.dQ=o(s.sub[7].content().split(/\n/)[1]),this.qInv=o(s.sub[8].content().split(/\n/)[1]),S(e)&&h(e,[{sha:256,saltLength:32}])&&(e.sha&&this.validSHA.includes(e.sha)&&(this.sha=e.sha),S(e.saltLength)&&e.saltLength!==this.saltLength&&(this.saltLength=e.saltLength),S(e.salt)&&(this.salt=e.salt,this.saltLength=this.salt.length))}component(t){let e=h(t,["number","string"],["n","d","p","q","dp","dq","qinv",1,3,4,5,6,7,8]);if(e!==!0)return e;let n=["n-1","d-3","p-4","q-5","dp-6","dq-7","qinv-8"],s;if(typeof t=="number")s=t;else if(typeof t=="string")s=n.find(p=>p.includes(t.toLowerCase()))?.split("-")[1];else return"Error: expected number or string of component";let{enc:i,pos:a}=this.key.sub[s].stream,{header:c,length:l}=this.key.sub[s],u=a+c,f=u+l,g=i[u]==0?1:0;return i.slice(u+g,f)}MGF1(t,e){let n=h(t,[Uint8Array]);if(n!==!0)return Error("parameter 1 should be Uint8Array");if(n=h(e,["number"]),n!==!0)return Error('parameter 2 should be "number"');let s=this.sha/8;if(e>Math.pow(2,32)*s)throw new Error("mask too long");let i=new Uint8Array(0),a=4,c=Math.ceil(e/s)-1;for(let l=0;l<=c;l++){let u=P(l,a),f=d(t,u),g=this.hash["sha"+this.sha].hash(f);i=d(i,g)}return i.slice(0,e)}EMSA_PSS_ENCODE(t){if(h(t,[Uint8Array]),t.length>Math.pow(2,61)-1)throw new Error("message too long");let e=this.hash["sha"+this.sha].hash(t),n=e.length,s=this.nUint8.length*8-1,i=Math.ceil(s/8),a=this.saltLength;if(i<n+a+2)throw new Error(`Error: emLen less than ${n} + ${a} + 2`);let c=this.salt?this.salt:self.crypto.getRandomValues(new Uint8Array(a)),l=d(new Uint8Array(8),e,c),u=this.hash["sha"+this.sha].hash(l),f=new Uint8Array(i-a-n-2),g=d(f,new Uint8Array([1]),c),p=this.MGF1(u,g.length),E=new Uint8Array(g.length);for(let m=0;m<g.length;m++)E[m]=g[m]^p[m];let A=O(E,i,s);return d(A,u,new Uint8Array([188]))}EMSA_PSS_VERIFY(t,e){if(h(t,[Uint8Array]),h(e,[Uint8Array]),t.length>Math.pow(2,61)-1)return"inconsistent";let n=this.hash["sha"+this.sha].hash(t),s=n.length,i=this.nUint8.length*8-1,a=Math.ceil(i/8),c=this.saltLength;if(a<s+c+2||e[e.length-1]!==188)return"inconsistent";let l=e.slice(0,a-s-1),u=e.slice(a-s-1,a-1);if(H(l,a,i)==!1)return"inconsistent";let g=this.MGF1(u,l.length),p=new Uint8Array(l.length);for(let y=0;y<p.length;y++)p[y]=l[y]^g[y];let E=O(p,a,i),A=a-s-c-2;if(!E.slice(0,A).every(y=>y===0)||E[A]!==1)return"inconsistent";let m=p.slice(p.length-c),_=d(new Uint8Array(8),n,m);return this.hash["sha"+this.sha].hash(_).every((y,R)=>y===u[R])?"consistent":"inconsistent"}RSASSA_PSS_SIGN(t){h(t,[Uint8Array]);let e=this.EMSA_PSS_ENCODE(t),n=w(e),s=T(n,{n:this.n,d:this.d});return P(s,this.nUint8.length)}RSASSA_PSS_VERIFY(t={n:BigInt(0),e:BigInt(0)},e,n){if(h(t,[{n:BigInt(0),e:BigInt(0)}]),h(e,[Uint8Array]),h(n,[Uint8Array]),n.length!==this.nUint8.length)return TypeError(`Error: signature length at ${n.length} is not match with modulus length at ${this.nUint8.length}`);let s=w(n),i=I(s,t),a=Math.ceil((this.nUint8.length*8-1)/8),c=P(i,a);return this.EMSA_PSS_VERIFY(e,c)=="consistent"?"valid signature":"invalid signature"}},M=r=>r===void 0,S=r=>M(r)==!1;function F(r){return typeof r!="string"?!1:/^(-----BEGIN (RSA PRIVATE|PRIVATE) KEY-----\n?(?:[A-Za-z0-9+/=]+\n?)*-----END (RSA PRIVATE|PRIVATE) KEY-----)\n?$/.test(r)}function N(r){let t=r;for(;;){let e=U.commonTypes.map(s=>{let i=U.match(t,s);return{type:s,match:i.recognized/i.total}}).sort((s,i)=>i.match-s.match);if(e[0].match==1)return delete t.def,{type:e[0].type,key:t};if(t.sub.length<1)throw Error("Key is not found ");t=C(t.sub)}}function C(r){let t=null;for(let e of r)e.hasOwnProperty("length")&&(!t||e.length>t.length)&&(t=e);return delete t.def,t}function d(...r){let t=new Uint8Array(0),e=t;for(let n of r)t=new Uint8Array(n.length+e.length),t.set(e),t.set(n,e.length),e=t;return t}function w(r){h(r,[Uint8Array,Array]);let t=o(0),e=r.length;for(let n=0;n<e;n++){let s=r.at(n);t=t.plus(o(s).multiply(o(256).pow(e-n-1)))}return t}function D(r,t){return b(r,t).map(e=>String.fromCharCode(e)).join("")}function P(r,t){return new Uint8Array(b(r,t))}function b(r,t){let e=h(r,[o,"number"]);if(e instanceof TypeError)return e;if(r=o(r),r.isNegative())return TypeError("Input x must be a non-negative (big)-integer");if(e=h(t,[o,"number"]),e instanceof TypeError)return e;if(t=o(t),t.lesserOrEquals(0))return TypeError("Input xLen must be a positive integer");let n=o(256).pow(t);if(r.greaterOrEquals(n))return TypeError("integer too large");let s=[];for(let i=t.minus(1);i.greaterOrEquals(0);i=i.minus(1)){let a=r.divide(o(256).pow(i));s.push(a),r=r.minus(a.multiply(o(256).pow(i)))}return s}function T(r,t){let e=h(r,[o,"number"]);if(e instanceof TypeError||(e=h(t,[{n:o(0),d:o(0)}]),e instanceof TypeError))return e;let{n,d:s}=t;return o(r).isNegative()||o(r).greaterOrEquals(n)?TypeError("message representative out of range"):o(r).modPow(s,n)}function I(r,t){let e=h(r,[o,"number"]);if(e instanceof TypeError||(e=h(t,[{n:o(0),e:o(0)}]),e instanceof TypeError))return e;let{n,e:s}=t;return o(r).isNegative()||o(r).greaterOrEquals(n)?TypeError("message representative out of range"):o(r).modPow(s,n)}function O(r,t,e){let n=Math.floor((t*8-e)/8),s=(t*8-e)%8,i=new Uint8Array(r.length);i.fill(0,0,n),i.set(r.subarray(n),n);let a=r[n]&255>>s;return i[n]=a,i}function H(r,t,e){let n=Math.floor((t*8-e)/8),s=(t*8-e)%8,i=new Uint8Array(n);if(i.length==0)return!0;i[0]=r[n]&~(255>>s),n<r.length&&i.set(r.subarray(n),n);for(let a of i)if(a!==0)return!1;return!0}export{D as I2OSP,b as I2OSP_array,P as I2OSP_uint8,w as OS2IP,v as RSAKey,T as RSASP1,I as RSAVP1};
