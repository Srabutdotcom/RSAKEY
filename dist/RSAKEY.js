import{ASN1 as k}from"npm:@lapo/asn1js";import{Base64 as q}from"npm:@lapo/asn1js/base64.js";import{Defs as A}from"npm:@lapo/asn1js/defs.js";import a from"npm:big-integer";import{validate as h}from"https://deno.land/x/validatevalue@v1.0.2/mod.js";import*as R from"@stablelib/sha256";import*as L from"@stablelib/sha384";import*as V from"@stablelib/sha512";var v=class{validSHA=[256,384,512];sha=256;saltLength=32;hash={sha256:R,sha384:L,sha512:V};OS2IP=P;I2OSP=D;I2OSP_array=w;I2OSP_uint8=w;RSASP1=I;RSAVP1=C;constructor(t,e){if(O(t))return TypeError("Parameter 1 is mandatory in the form of PEM String");if(B(t)==!1)return TypeError("Parameter 1 is not in the form of PEM String");this.enc=q.unarmor(t),this.asn1=k.decode(this.enc),this.key=N(this.asn1),this.nUint8=this.component("n"),this.version=this.key.getContent(0),this.n=this.key.getContent(1),this.e=a(this.key.sequence[2].content()),this.d=this.key.getContent(3),this.p=this.key.getContent(4),this.q=this.key.getContent(5),this.dP=this.key.getContent(6),this.dQ=this.key.getContent(7),this.qInv=this.key.getContent(8),b(e)&&h(e,[{sha:256,saltLength:32}])&&(e.sha&&this.validSHA.includes(e.sha)&&(this.sha=e.sha),b(e.saltLength)&&e.saltLength!==this.saltLength&&(this.saltLength=e.saltLength),b(e.salt)&&(this.salt=e.salt,this.saltLength=this.salt.length))}component(t){let e=h(t,["number","string"],["n","d","p","q","dp","dq","qinv",1,3,4,5,6,7,8]);if(e!==!0)return e;let r=["n-1","d-3","p-4","q-5","dp-6","dq-7","qinv-8"],i;if(typeof t=="number")i=t;else if(typeof t=="string")i=r.find(g=>g.includes(t.toLowerCase()))?.split("-")[1];else return"Error: expected number or string of component";let{enc:s,pos:o}=this.key.sequence[i].stream,{header:l,length:c}=this.key.sequence[i],u=o+l,p=u+c,f=s[u]==0?1:0;return s.slice(u+f,p)}MGF1(t,e){let r=h(t,[Uint8Array]);if(r!==!0)return Error("parameter 1 should be Uint8Array");if(r=h(e,["number"]),r!==!0)return Error('parameter 2 should be "number"');let i=this.sha/8;if(e>Math.pow(2,32)*i)throw new Error("mask too long");let s=new Uint8Array(0),o=4,l=Math.ceil(e/i)-1;for(let c=0;c<=l;c++){let u=U(c,o),p=S(t,u),f=this.hash["sha"+this.sha].hash(p);s=S(s,f)}return s.slice(0,e)}EMSA_PSS_ENCODE(t){if(h(t,[Uint8Array]),t.length>Math.pow(2,61)-1)throw new Error("message too long");let e=this.hash["sha"+this.sha].hash(t),r=e.length,i=this.nUint8.length*8-1,s=Math.ceil(i/8),o=this.saltLength;if(s<r+o+2)throw new Error(`Error: emLen less than ${r} + ${o} + 2`);let l=this.salt?this.salt:self.crypto.getRandomValues(new Uint8Array(o)),c=S(new Uint8Array(8),e,l),u=this.hash["sha"+this.sha].hash(c),p=new Uint8Array(s-o-r-2),f=S(p,new Uint8Array([1]),l),g=this.MGF1(u,f.length),d=new Uint8Array(f.length);for(let m=0;m<f.length;m++)d[m]=f[m]^g[m];let E=M(d,s,i);return S(E,u,new Uint8Array([188]))}EMSA_PSS_VERIFY(t,e){if(h(t,[Uint8Array]),h(e,[Uint8Array]),t.length>Math.pow(2,61)-1)return"inconsistent";let r=this.hash["sha"+this.sha].hash(t),i=r.length,s=this.nUint8.length*8-1,o=Math.ceil(s/8),l=this.saltLength;if(o<i+l+2||e[e.length-1]!==188)return"inconsistent";let c=e.slice(0,o-i-1),u=e.slice(o-i-1,o-1);if(H(c,o,s)==!1)return"inconsistent";let f=this.MGF1(u,c.length),g=new Uint8Array(c.length);for(let y=0;y<g.length;y++)g[y]=c[y]^f[y];let d=M(g,o,s),E=o-i-l-2;if(!d.slice(0,E).every(y=>y===0)||d[E]!==1)return"inconsistent";let m=g.slice(g.length-l),T=S(new Uint8Array(8),r,m);return this.hash["sha"+this.sha].hash(T).every((y,_)=>y===u[_])?"consistent":"inconsistent"}RSASSA_PSS_SIGN(t){h(t,[Uint8Array]);let e=this.EMSA_PSS_ENCODE(t),r=P(e),i=I(r,{n:this.n,d:this.d});return U(i,this.nUint8.length)}RSASSA_PSS_VERIFY(t={n:BigInt(0),e:BigInt(0)},e,r){if(h(t,[{n:BigInt(0),e:BigInt(0)}]),h(e,[Uint8Array]),h(r,[Uint8Array]),r.length!==this.nUint8.length)return TypeError(`Error: signature length at ${r.length} is not match with modulus length at ${this.nUint8.length}`);let i=P(r),s=C(i,t),o=Math.ceil((this.nUint8.length*8-1)/8),l=U(s,o);return this.EMSA_PSS_VERIFY(e,l)=="consistent"?"valid signature":"invalid signature"}},O=n=>n===void 0,b=n=>O(n)==!1;function B(n){return typeof n!="string"?!1:/^(-----BEGIN (RSA PRIVATE|PRIVATE) KEY-----\r?\n?(?:[A-Za-z0-9+/=]+\r?\n?)*-----END (RSA PRIVATE|PRIVATE) KEY-----)\r?\n?$/.test(n)}function F(n){let t=n;for(;;){let e=A.commonTypes.map(i=>{let s=A.match(t,i);return{type:i,match:s.recognized/s.total}}).sort((i,s)=>s.match-i.match);return A.match(t,e[0].type),t;if(e[0].match==1)return delete t.def,{type:e[0].type,key:t};if(t.sub.length<1)throw Error("Key is not found ");t=x(t.sub)}}function N(n){let t=F(n),e=t.def.description;if(["PKCS#8 private key","PKCS#1 RSA private key"].includes(e)!==!0)throw Error("RSA Private Key is not found");return t.def.description=="PKCS#8 private key"&&(A.match(t.sub[2].sub[0],A.commonTypes[3].type),t.sequence=t.sub[2].sub[0].sub),t.def.description=="PKCS#1 RSA private key"&&(t.sequence=t.sub),t.getContent=r.bind(t),t;function r(i){let{header:s,length:o,stream:{enc:l,pos:c}}=this.sequence[i],u=c+s+o,p=c+s,f=Array.from(l.subarray(p,u),d=>Number(d).toString(16).padStart(2,"0")).join("");return a(f,16)}}function x(n){let t=null;for(let e of n)e.hasOwnProperty("length")&&(!t||e.length>t.length)&&(t=e);return delete t.def,t}function S(...n){let t=new Uint8Array(0),e=t;for(let r of n)t=new Uint8Array(r.length+e.length),t.set(e),t.set(r,e.length),e=t;return t}function P(n){h(n,[Uint8Array,Array]);let t=a(0),e=n.length;for(let r=0;r<e;r++){let i=n.at(r);t=t.plus(a(i).multiply(a(256).pow(e-r-1)))}return t}function D(n,t){return w(n,t).map(e=>String.fromCharCode(e)).join("")}function U(n,t){return new Uint8Array(w(n,t))}function w(n,t){let e=h(n,[a,"number"]);if(e instanceof TypeError)return e;if(n=a(n),n.isNegative())return TypeError("Input x must be a non-negative (big)-integer");if(e=h(t,[a,"number"]),e instanceof TypeError)return e;if(t=a(t),t.lesserOrEquals(0))return TypeError("Input xLen must be a positive integer");let r=a(256).pow(t);if(n.greaterOrEquals(r))return TypeError("integer too large");let i=[];for(let s=t.minus(1);s.greaterOrEquals(0);s=s.minus(1)){let o=n.divide(a(256).pow(s));i.push(o),n=n.minus(o.multiply(a(256).pow(s)))}return i}function I(n,t){let e=h(n,[a,"number"]);if(e instanceof TypeError||(e=h(t,[{n:a(0),d:a(0)}]),e instanceof TypeError))return e;let{n:r,d:i}=t;return a(n).isNegative()||a(n).greaterOrEquals(r)?TypeError("message representative out of range"):a(n).modPow(i,r)}function C(n,t){let e=h(n,[a,"number"]);if(e instanceof TypeError||(e=h(t,[{n:a(0),e:a(0)}]),e instanceof TypeError))return e;let{n:r,e:i}=t;return a(n).isNegative()||a(n).greaterOrEquals(r)?TypeError("message representative out of range"):a(n).modPow(i,r)}function M(n,t,e){let r=Math.floor((t*8-e)/8),i=(t*8-e)%8,s=new Uint8Array(n.length);s.fill(0,0,r),s.set(n.subarray(r),r);let o=n[r]&255>>i;return s[r]=o,s}function H(n,t,e){let r=Math.floor((t*8-e)/8),i=(t*8-e)%8,s=new Uint8Array(r);if(s.length==0)return!0;s[0]=n[r]&~(255>>i),r<n.length&&s.set(n.subarray(r),r);for(let o of s)if(o!==0)return!1;return!0}export{D as I2OSP,w as I2OSP_array,U as I2OSP_uint8,P as OS2IP,v as RSAKey,I as RSASP1,C as RSAVP1};
